## Author: Dory Abelman
## Based on scripts from Derek Wong
## Plot ROCs for ML classifier data
## Cancer type
## Original date: Aug 2023
## Updated Nov 2023, Jan 2024
## Updated March - May 2024


## Load libraries
library(caret)
library(dplyr)
library(tidyverse)
library(pROC)
library(ggpubr)

## This script takes the individual rds files from each of the comparisons and plots them together in the ROC and AUC curves

### Set variables
## This is the path for the plots for the machine learning outputs generated by the cancer_vs_normal_script
path <- "Final Data May 2024/Machine_learning_outputs/Cancer_type/"

files <- list.files(path = path, pattern = "\\.rds$")

classification_df <- data.frame(file = files, stringsAsFactors = FALSE)

# Extract 'type1' and 'type2' from the file names
classification_df$type1 <- sub(".*outcomes_([A-Za-z0-9_]+)_vs_.*", "\\1", classification_df$file)
classification_df$type2 <- sub(".*_vs_(.*)\\.rds", "\\1", classification_df$file)

# Extract the 'Analysis' column 
classification_df$Analysis <- sub("^Classifier_", "", sub("_outcomes_.*", "", classification_df$file))

## Remove the row with analysis "Combined_motif_methylation_PCs_all" since not using it
classification_df <- classification_df %>%
  filter(Analysis != "Combined_motif_methylation_PCs_all")

# To work with for loop
comparisons_classification <- classification_df %>% select(type1, type2)

# Get all types but keep unique 
# Create a function to sort each pair of types
sort_pair <- function(row) {
  return(sort(c(row['type1'], row['type2'])))
}

# Apply the function row-wise and store the sorted pairs in a new dataframe
sorted_comparisons <- t(apply(comparisons_classification, 1, sort_pair))
sorted_comparisons_df <- data.frame(type1 = sorted_comparisons[, 1], type2 = sorted_comparisons[, 2])

# Remove duplicates
unique_comparisons_df <- unique(sorted_comparisons_df)

## Run with and without PCAs seperately 
## Run on PCAs seperately
for (i in 1:nrow(unique_comparisons_df)) {
  
  # Set variables from the dataframe
  type1 <- unique_comparisons_df$type1[i]
  type2 <- unique_comparisons_df$type2[i]
  
  # Create a regex pattern to match type1 and type2 in either order
  pattern_to_search <- paste0("(", type1, "_vs_", type2, "|", type2, "_vs_", type1, ")\\.rds")
  
  # List files that match the pattern
  filenames_short <- list.files(path, pattern = pattern_to_search, full.names = FALSE)
  filenames <- list.files(path, pattern = pattern_to_search, full.names = TRUE)
  
  # Function to create and save plots
  create_and_save_plots <- function(data_roc, data_auc, data_cm, suffix) {
    
    # Ensure auc is numeric
    data_auc$auc <- as.numeric(as.character(data_auc$auc))
    
    # Sort data_auc by AUC in ascending order
    data_auc <- data_auc[order(data_auc$auc),]
    
    # Count the number of rows in data_auc
    n_rows <- nrow(data_auc)
    
    # Create a sequence for the y aesthetic
    y_values <- seq(0, 0.3, length.out = n_rows)
    
    # Add the y_values to data_auc
    data_auc$y_values <- y_values
    
    # Define colors 
    my_color_palette <- c(
      "Fragment Ratio" = "#1f77b4",
      "End Motif" = "#ff7f0e",
      "Nucleosome Peak" = "#2ca02c",
      "Methylation" = "#d62728",
      "Combined All Features PCs >5%" = "#9467bd",
      "PCA Fragment Ratio" = "#17becf",
      "PCA End Motif" = "#bcbd22",
      "PCA Insert Size" = "#e377c2",
      "PCA Methylation" = "#7f7f7f",
      "PCA Nucleosome Peak" = "#8c564b",
      "End Motif + Methylation PCs >1%" = "#8B0000",  # Dark Red
      "End Motif + Methylation + Ratios PCs >1%" = "#008080"  # Teal
    )
    
    AUC_plot <- ggplot(data_roc) +
      geom_line(aes(sensitivity, specificity, group = Metric, color = Metric)) +
      geom_abline(intercept = 0, linetype = "dashed", alpha = 0.5) +
      geom_text(data = data_auc, aes(x = 0.7, y = seq(0, 0.34, length.out = n_rows), color = Metric, label = paste0(Metric, " = ", auc)), size = 2.5) +
      scale_color_manual(values = my_color_palette) + 
      xlab("False Positive Rate") + 
      ylab("True Positive Rate") +
      ggtitle("ROC Curves") + 
      theme +
      theme(legend.position = "none") +
      theme(legend.text = element_text(size = 6))
    
    AUC_plot
    
    CM_plot <- ggplot(data_cm) +
      geom_point(aes(sensitivity, specificity, color = Metric), size = 3) +
      geom_hline(yintercept = 0.5, linetype = "dashed", color = "grey") +
      geom_vline(xintercept = 0.5, linetype = "dashed", color = "grey") +
      scale_color_manual(values = my_color_palette) + 
      xlab("Sensitivity") + 
      ylab("Specificity") +
      labs(color = "") +
      ggtitle("Performance") + 
      theme +
      theme(legend.position = c(0.5, 0.21)) +
      theme(legend.text = element_text(size = 6)) +
      scale_y_continuous(limits = c(0,1)) +
      scale_x_continuous(limits = c(0,1)) +
      guides(color = guide_legend(ncol = 2))
    CM_plot
    
    fig <- ggarrange(AUC_plot, CM_plot, align = "h")
    annotate_figure(fig, top = text_grob(paste0(type1, " vs ", type2), face = "bold", size = 14))
    ggsave(file.path(path, paste0("classifier_performance_", type1, "_vs_", type2, "_", suffix, "_cancer_type_updated.pdf")), width = 9, height = 4.5)
  }
  
  for (filter_type in c("all", "PCA")) {
    if (filter_type == "PCA") {
      filtered_classification_df <- classification_df %>% filter(str_detect(Analysis, "PC"))
    } else {
      filtered_classification_df <- classification_df
    }
    
    # Extract the analysis and filenames from the filtered dataframe
    filtered_filenames_short <- filtered_classification_df$file
    filtered_analyses <- filtered_classification_df$Analysis
    
    data_roc <- data.frame()
    data_auc <- data.frame()
    data_cm <- data.frame()
    
    for (j in seq_along(filenames)) {
      file <- filenames[[j]]
      filename_short <- filenames_short[[j]]
      
      if (!(filename_short %in% filtered_filenames_short)) next
      
      analysis <- filtered_analyses[filtered_filenames_short == filename_short]
      
      data <- readRDS(file)
      data <- unlist(data, recursive = FALSE)
      data <- bind_rows(data)
      
      data$ActualClass <- factor(data$ActualClass, levels = c(type1, type2))
      data$PredictedClass <- factor(data$PredictedClass, levels = c(type1, type2))
      cm <- confusionMatrix(data$PredictedClass, data$ActualClass)
      cm <- data.frame(Metric = analysis,
                       sensitivity = cm[["byClass"]][["Sensitivity"]],
                       specificity = cm[["byClass"]][["Specificity"]])
      
      data$ActualClass <- ifelse(data$ActualClass == type2, 0, 1)
      
      roc <- roc(data$ActualClass, data[[type2]])
      specificity <- roc[["specificities"]]
      sensitivity <- roc[["sensitivities"]]
      sensitivity <- 1 - sensitivity
      
      roc <- as.data.frame(cbind(sensitivity, specificity))
      colnames(roc) <- c("sensitivity", "specificity")
      roc$Metric <- analysis
      
      auc <- auc(data$ActualClass, data[[type2]])
      auc <- format(signif(auc, digits = 3), nsmall = 3)
      auc <- data.frame(Metric = analysis, auc = auc)
      
      data_roc <- rbind(data_roc, roc)
      data_auc <- rbind(data_auc, auc)
      data_cm <- rbind(data_cm, cm)
    }
    
    # Function to get the appropriate labels for each unique metric
    get_labels <- function(unique_metrics) {
      label_mapping <- list(
        "DELFI_ratios" = "Fragment Ratio",
        "End_motif" = "End Motif",
        "Nucleosome_Peak" = "Nucleosome Peak",
        "Methylation" = "Methylation",
        "Combined_features_PCA" = "Combined All Features PCs >5%",
        "PCA_DELFI_ratios" = "PCA Fragment Ratio",
        "PCA_End_motif" = "PCA End Motif",
        "PCA_Insert_Size" = "PCA Insert Size",
        "PCA_Methylation" = "PCA Methylation",
        "PCA_Nucleosome_Peak" = "PCA Nucleosome Peak",
        "Combined_endmotif_methylation" = "End motif + methylation",
        "Combined_motif_methylation_PCs_1pct" = "End Motif + Methylation PCs >1%",
        "Combined_motif_methylation_ratios_PCs_1pct" = "End Motif + Methylation + Ratios PCs >1%"
      )
      
      sapply(unique_metrics, function(x) label_mapping[[x]])
    }
    
    unique_metrics <- unique(data_roc$Metric)
    
    data_roc$Metric <- factor(data_roc$Metric, levels = unique_metrics, labels = get_labels(unique_metrics))
    data_auc$Metric <- factor(data_auc$Metric, levels = unique_metrics, labels = get_labels(unique_metrics))
    data_cm$Metric <- factor(data_cm$Metric, levels = unique_metrics, labels = get_labels(unique_metrics))
    
    create_and_save_plots(data_roc, data_auc, data_cm, ifelse(filter_type == "PCA", "PCA", "all_features"))
  }
}



## Now get AUC data
# Initialize an empty dataframe to store the combined AUC values
# First reget classification df since removal of one row for plotting creates errors
classification_df <- data.frame(file = files, stringsAsFactors = FALSE)

# Extract 'type1' and 'type2' from the file names
classification_df$type1 <- sub(".*outcomes_([A-Za-z0-9_]+)_vs_.*", "\\1", classification_df$file)
classification_df$type2 <- sub(".*_vs_(.*)\\.rds", "\\1", classification_df$file)

# Extract the 'Analysis' column 
classification_df$Analysis <- sub("^Classifier_", "", sub("_outcomes_.*", "", classification_df$file))

all_data_auc <- data.frame()

for (i in 1:nrow(unique_comparisons_df)) {
  
  # Set variables from the dataframe
  type1 <- unique_comparisons_df$type1[i]
  type2 <- unique_comparisons_df$type2[i]
  
  # Create a regex pattern to match type1 and type2 in either order
  pattern_to_search <- paste0("(", type1, "_vs_", type2, "|", type2, "_vs_", type1, ")\\.rds")
  
  # List files that match the pattern
  filenames_short <- list.files(path, pattern = pattern_to_search, full.names = FALSE)
  filenames <- list.files(path, pattern = pattern_to_search, full.names = TRUE)
  
  # Extract the analysis from the dataframe
  matching_rows <- classification_df$file %in% filenames_short
  analyses <- unique(classification_df$Analysis[matching_rows])
  
  data_roc <- data.frame()
  data_auc <- data.frame()
  data_cm <- data.frame()
  
  for (j in c(1:length(filenames))) {
    
    ### Set variables
    file <- filenames[[j]]
    analysis <- analyses[[j]]
    
    ### Read in file
    data <- readRDS(file)
    
    ### Unlist files
    data <- unlist(data, recursive = FALSE)
    data <- bind_rows(data)
    
    ### Make confusion matrix
    data$ActualClass <- factor(data$ActualClass, levels = c(type1, type2))
    data$PredictedClass <- factor(data$PredictedClass, levels = c(type1, type2))
    cm <- confusionMatrix(data$PredictedClass, data$ActualClass)
    cm <- data.frame(Metric = analysis,
                     sensitivity = cm[["byClass"]][["Sensitivity"]],
                     specificity = cm[["byClass"]][["Specificity"]])
    
    ### Format table
    data$ActualClass <- ifelse(data$ActualClass == type2, 0, 1)
    
    ### Calculate auc and roc values
    roc <- roc(data$ActualClass, data[[type2]])
    specificity <- roc[["specificities"]]
    sensitivity <- roc[["sensitivities"]]
    sensitivity <- 1 - sensitivity
    
    roc <- as.data.frame(cbind(sensitivity, specificity))
    colnames(roc) <- c("sensitivity", "specificity")
    roc$Metric <- analysis
    
    auc <- auc(data$ActualClass, data[[type2]])
    auc <- format(signif(auc, digits = 3), nsmall = 3)
    auc <- data.frame(Metric = analysis, auc = auc)
    
    ### Append to dataframes
    data_roc <- rbind(data_roc, roc)
    data_auc <- rbind(data_auc, auc)
    data_cm <- rbind(data_cm, cm)
    
    auc$Type1 <- type1
    auc$Type2 <- type2
    
    # Append to the all_data_auc dataframe
    all_data_auc <- rbind(all_data_auc, auc)
  }
}


## Now make a heatmap based on AUC data
## For triangle format 

# Function to create the AUC matrix for each metric with diagonal but not lower third
create_auc_matrix <- function(df) {
  # Convert AUC to numeric if it's not already
  df$auc <- as.numeric(as.character(df$auc))
  
  # Spread the dataframe to a wide format
  spread_df <- df %>%
    select(Metric, Type1, Type2, auc) %>%
    spread(key = Type2, value = auc)
  
  # Set rownames to the Type1 column
  rownames(spread_df) <- spread_df$Type1
  
  # Remove the Metric and Type1 columns for matrix conversion
  spread_df <- spread_df[,-1] # Remove Metric
  spread_df <- spread_df[,-1] # Remove Type1
  
  # Convert to matrix
  mat <- as.matrix(spread_df)
  
  # Create a symmetric matrix by copying upper triangle to lower triangle
  mat[lower.tri(mat)] <- t(mat)[lower.tri(mat)]
  
  # Set lower triangle (excluding diagonal) to NA
  mat[lower.tri(mat)] <- NA
  
  # Return the matrix
  return(mat)
}

# Replace "eye_cancer" with "uveal_melanoma" in Type1 and Type2 columns
#all_data_auc <- all_data_auc %>%
#  mutate(
#    Type1 = ifelse(Type1 == "eye_cancer", "uveal_melanoma", Type1),
#    Type2 = ifelse(Type2 == "eye_cancer", "uveal_melanoma", Type2)
#  )

# Split data by metric and create AUC matrices
auc_matrices <- all_data_auc %>%
  split(.$Metric) %>%
  lapply(create_auc_matrix)

# Now let's plot the heatmaps without the diagonal and lower part
library(ComplexHeatmap)
library(circlize)

## Updated plots
# Define a custom color scale
auc_colors <- colorRamp2(c(0.5, 0.75, 1), c("#d0e1f9", "#74a9cf", "#0570b0"))


# Creating the heatmaps - original - works better
pdf("Heatmaps_per_Metric May 2024, updated colors cancer type 3.pdf") # Start the PDF device to save all plots to a single file
for(metric in names(auc_matrices)) {
  # Create a heatmap for each metric
  heatmap_matrix <- auc_matrices[[metric]]
  
  # Replacing NA values with 0 for better visualization
  #  heatmap_matrix[is.na(heatmap_matrix)] <- 0 
  
  # Create the heatmap
  ht <- Heatmap(heatmap_matrix, 
                name = "AUC", 
                col = auc_colors, #added
                cluster_rows = FALSE, 
                cluster_columns = FALSE, 
                show_row_names = TRUE, 
                show_column_names = TRUE,
                column_title = metric, 
                row_title = "Cancer type",
                cell_fun = function(j, i, x, y, width, height, fill) {
                  if(!is.na(heatmap_matrix[i, j])) {
                    grid.text(sprintf("%.3f", heatmap_matrix[i, j]), x, y, gp = gpar(fontsize = 10))
                  }
                })
  
  # Draw the heatmap
  print(ht)
}
dev.off() # Close the PDF device


# Create heatmaps and save them as separate PDFs
for(metric in names(auc_matrices)) {
  # Create a heatmap for each metric
  heatmap_matrix <- auc_matrices[[metric]]
  
  # Define the filename for the PDF
  pdf_filename <- paste0("Heatmap_sample_type", metric, "_May_2024_updated.pdf")
  
  # Start the PDF device
  pdf(pdf_filename)
  
  # Create the heatmap
  ht <- Heatmap(heatmap_matrix, 
                name = "AUC", 
                col = auc_colors,
                cluster_rows = FALSE, 
                cluster_columns = FALSE, 
                show_row_names = TRUE, 
                show_column_names = TRUE,
                column_title = metric, 
                row_title = "Cancer type",
                cell_fun = function(j, i, x, y, width, height, fill) {
                  if(!is.na(heatmap_matrix[i, j])) {
                    grid.text(sprintf("%.3f", heatmap_matrix[i, j]), x, y, gp = gpar(fontsize = 10))
                  }
                })
  
  # Draw the heatmap
  draw(ht)
  
  # Close the PDF device
  dev.off()
}


### See which metric is best 
# Ensure both Type1 and Type2 are ordered consistently
all_data_auc_sorted <- all_data_auc %>%
  rowwise() %>%
  mutate(
    ordered_Type1 = sort(c(Type1, Type2))[1],
    ordered_Type2 = sort(c(Type1, Type2))[2]
  ) %>%
  ungroup() %>%
  select(-Type1, -Type2) %>%
  rename(Type1 = ordered_Type1, Type2 = ordered_Type2)


# Filter for comparisons involving PCs
pc_comparisons <- all_data_auc_sorted %>%
  filter(str_detect(Metric, "PC"))

## Change DELFI ratios to fragment ratios and rename the uveal melanoma 
# Replace 'DELFI' with 'Fragment' in the Metric column
pc_comparisons <- pc_comparisons %>%
  mutate(Metric = str_replace(Metric, "DELFI", "Fragment"))

# Replace 'eye_cancer' with 'uveal_melanoma' in the Type1 and Type2 columns
pc_comparisons <- pc_comparisons %>%
  mutate(Type1 = str_replace(Type1, "eye_cancer", "uveal_melanoma"),
         Type2 = str_replace(Type2, "eye_cancer", "uveal_melanoma"))

## Export 
write.table(pc_comparisons, file = "AUCs for cancer type comparisons.txt", sep = "\t", quote = F, row.names = F)

# Calculate the mean and range of AUC for each Metric and cancer type comparison
# Range not particulary relevant since summing to one per group here as aggregate
mean_range_auc <- pc_comparisons %>%
  mutate(comparison = paste(Type1, "vs", Type2)) %>%
  group_by(comparison, Metric) %>%
  summarize(
    mean_auc = mean(as.numeric(auc)),
    min_auc = min(as.numeric(auc)),
    max_auc = max(as.numeric(auc)),
    .groups = 'drop'
  )

# Identify the highest mean AUC for each cancer type comparison
best_metrics <- mean_range_auc %>%
  group_by(comparison) %>%
  slice_max(mean_auc) %>%
  ungroup()

## See difference of best metric to methylation
# Extract the AUC values for both the best metric and the PCA_Methylation metric
auc_comparison <- mean_range_auc %>%
  dplyr::filter(Metric == "PCA_Methylation") %>%
  rename(pca_methylation_auc = mean_auc) %>%
  dplyr::select(comparison, pca_methylation_auc) %>%
  left_join(best_metrics %>% rename(best_metric_auc = mean_auc), by = "comparison")

# Calculate the gain (difference) between the best metric's AUC and the PCA_Methylation metric's AUC
auc_comparison <- auc_comparison %>%
  mutate(gain = best_metric_auc - pca_methylation_auc) %>%
  select(-min_auc, -max_auc)

## Now summarise these statistics
# Add a column to indicate if the comparison involves healthy
auc_comparison <- auc_comparison %>%
  mutate(involves_healthy = ifelse(grepl("healthy", comparison), "between_healthy", "between_cancer_types"))

# Summarize gains for comparisons involving healthy
healthy_summary <- auc_comparison %>%
  filter(involves_healthy == "between_healthy") %>%
  dplyr::summarize(
    min_gain_healthy = min(gain, na.rm = TRUE),
    max_gain_healthy = max(gain, na.rm = TRUE),
    mean_gain_healthy = mean(gain, na.rm = TRUE)
  )

# Summarize gains for comparisons not involving healthy
non_healthy_summary <- auc_comparison %>%
  filter(involves_healthy == "between_cancer_types") %>%
  summarize(
    min_gain_non_healthy = min(gain, na.rm = TRUE),
    max_gain_non_healthy = max(gain, na.rm = TRUE),
    mean_gain_non_healthy = mean(gain, na.rm = TRUE)
  )

# Combine the summaries
summary_table <- bind_cols(healthy_summary, non_healthy_summary)
